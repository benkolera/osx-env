#+TITLE: Emacs Configuration
#+AUTHOR: Ben Kolera
#+EMAIL: ben.kolera@gmail.com

* Emacs Configuration in an Org file
  This configuration is largely based off of Jack Henahan's [[https://github.com/jhenahan/emacs.d/blob/master/emacs-init.org][wonderful configuration]].

  Ignore the line below. It is merely a warning to insert into the generated emacs-init.el file.

  #+NAME: Note
  #+BEGIN_SRC emacs-lisp
  ;;; ------------------------------------------
  ;;; Do not edit this file. It was tangled from
  ;;; an org file.
  ;;; ------------------------------------------
  #+END_SRC

* Dependency Management with =req-package=
  [[https://github.com/edvorg/req-package][req-package]] is a wrapper on top of [[https://github.com/jwiegley/use-package][use-package]], a package dependency
  management tool. The documentation for =use-package= is immensely helpful for
  figuring out how to describe package dependencies and settings. =req-package=
  adds the =:require= keyword which allows us to define dependencies between
  related packages.
** Initialize =req-package=
   With the preceding process complete, we just need to add the following line
   to our init file to begin using =req-package=:

   #+BEGIN_SRC emacs-lisp
     (require 'req-package)
     (setq custom-file "~/.emacs.d/custom.el")
     (load custom-file)
   #+END_SRC

* Evil
  I have to remap some normal mode keys to suit my dvorak layout.

   #+BEGIN_SRC emacs-lisp
     (req-package evil
       :require (undo-tree evil-surround ace-jump-mode)
       :ensure evil
       :init
       (progn
         (setq evil-default-cursor t)
         (evil-mode 1)
         (setq evil-motion-state-modes
               (append evil-emacs-state-modes evil-motion-state-modes))
         (setq evil-emacs-state-modes '(magit-mode dired-mode)))
       :config
       (progn
         (define-key evil-normal-state-map "u" 'undo)
         ;; Left, down, up, right: [htns] (previously: [hjkl]).
         (define-key evil-motion-state-map "h" 'evil-backward-char)
         (define-key evil-motion-state-map "n" 'evil-next-line)
         (define-key evil-motion-state-map "t" 'evil-previous-line)
         (define-key evil-motion-state-map "s" 'evil-forward-char) (define-key evil-normal-state-map "s" nil)

         ;; Down/up displayed line (as opposed to physical line): gt/gn (previously: gj/gk).
         (define-key evil-motion-state-map "gn" 'evil-next-visual-line) (define-key evil-motion-state-map "gj" nil)
         (define-key evil-motion-state-map "gt" 'evil-previous-visual-line) (define-key evil-motion-state-map "gk" nil)

         ;; First non-blank/last character of the line: H/S (previously: H/L -- first/last visible line in the window).
         (define-key evil-motion-state-map "H" 'evil-first-non-blank)
         (define-key evil-motion-state-map "S" 'evil-end-of-line) (define-key evil-normal-state-map "S" nil)

         ;; Join lines with/without changing whitespace: T/gT (previously: J/gJ).
         (define-key evil-normal-state-map "N" 'evil-join) (define-key evil-motion-state-map "N" nil)
         (define-key evil-normal-state-map "gN" 'evil-join-whitespace)

        ;; Jump before a given character forward/backward: j/J (previously: t/T).
        (define-key evil-motion-state-map "j" 'evil-find-char-to)
        (define-key evil-motion-state-map "J" 'evil-find-char-to-backward) (define-key evil-normal-state-map "J" nil)

        ;; Substitute (kill): k (previously: s).
        (define-key evil-normal-state-map "k" 'evil-substitute) (define-key evil-motion-state-map "k" nil)
        ;; K -- look up the keyword at point (like `man').

        ;; Next/previous search result: l/L (previously: n/N).
        (evil-ex-define-cmd "e[dit]" 'ido-find-file)
        (evil-ex-define-cmd "b[uffer]" 'ido-switch-buffer)

        (define-key evil-motion-state-map "l" 'evil-search-next)
        (define-key evil-motion-state-map "L" 'evil-search-previous)
         (bind-key "[escape]" 'keyboard-escape-quit evil-normal-state-map)
         (bind-key "[escape]" 'keyboard-escape-quit evil-visual-state-map)
         (bind-key "<escape>" 'keyboard-escape-quit)
         (evil-define-key 'normal
                          tern-mode-keymap "gd" 'tern-find-definition)))
   #+END_SRC

*** =evil-leader=
    =<leader>= is a really useful shorthand in Vim, and [[https://github.com/cofi/evil-leader][evil-leader]] brings the
    same facility to Evil. For really common commands, leader bindings can save
    those precious keystrokes.

    #+BEGIN_SRC emacs-lisp
      (req-package evil-leader
                   :require evil
                   :ensure evil-leader
                   :init
                   (progn
                     (evil-leader/set-leader "<SPC>")
                     (global-evil-leader-mode 1)
                     (evil-leader/set-key
                       "aw" 'ace-jump-word-mode
                       "ac" 'ace-jump-char-mode
                       "al" 'ace-jump-line-mode
                       "l" 'org-insert-link
                       "o" 'other-window
                       "d" 'delete-window
                       "D" 'delete-other-windows
                       "h" 'split-window-below
                       "v" 'split-window-right
                       "k" 'kill-buffer
                       "K" 'kill-buffer-and-window
                       "f" 'dired
                       "gs" 'magit-status
                       "gp" 'magit-pull)))
    #+END_SRC

*** =evil-surround=

    #+BEGIN_SRC emacs-lisp
      (req-package evil-surround
        :init (progn
         (global-evil-surround-mode 1)
         (evil-define-key 'operator evil-surround-mode-map "s" 'evil-forward-char)
         (evil-define-key 'visual evil-surround-mode-map "s" 'evil-forward-char)
         (evil-define-key 'visual evil-surround-mode-map "S" 'evil-end-of-line)
         (evil-define-key 'operator evil-surround-mode-map "k" 'evil-surround-edit)
         (evil-define-key 'visual evil-surround-mode-map "k" 'evil-surround-region)
         (evil-define-key 'visual evil-surround-mode-map "K" 'evil-Surround-region)
      ))
    #+END_SRC

*** =undo-tree=
    Standard Emacs undo is kind of confusing. [[http://www.dr-qubit.org/emacs.php#undo-tree][undo-tree]] replaces this with a
    simpler tree structure. It also allows us to visualize the tree directly.

    #+BEGIN_SRC emacs-lisp
      (req-package undo-tree
                   :diminish ""
                   :init
                   (progn
                     (setq undo-tree-auto-save-history t)
                     (global-undo-tree-mode)))
    #+END_SRC

*** =ace-jump-mode=
    #+BEGIN_SRC emacs-lisp
      (req-package ace-jump-mode)
    #+END_SRC

* Navigation
  Two main kickers here. Projectile and flx-ido.

** =flx=
   #+BEGIN_SRC emacs-lisp
   (req-package flx-ido
     :init
     (progn
       (ido-mode 1)
       (flx-ido-mode 1)
       (ido-everywhere 1)
       (setq ido-use-faces nil)))
   #+END_SRC

** =projectile=
  #+BEGIN_SRC emacs-lisp
  (req-package projectile
    :diminish ""
    :init
    (progn (projectile-global-mode)))
   #+END_SRC

** Window Movement
   #+BEGIN_SRC emacs-lisp
   (windmove-default-keybindings 'meta)
   #+END_SRC
* Org
  #+BEGIN_SRC emacs-lisp
    (req-package org
      :config
      (progn
        (org-babel-do-load-languages
          'org-babel-load-languages
          '((ditaa . t))) ; this line activates ditaa
        (setq org-ditaa-jar-path "/usr/local/Cellar/ditaa/0.9/libexec/ditaa0_9.jar")
        (add-hook 'org-mode-hook
                  '(lambda ()
                     (setq mode-name " ꙮ ")))
        (bind-key* "C-c c" 'org-capture)
        (bind-key* "C-c l" 'org-store-link)
        (bind-key* "C-c a" 'org-agenda)
        (bind-key* "C-c b" 'org-iswitch)))
  #+END_SRC

* UI
** Theme
   #+BEGIN_SRC emacs-lisp
     (req-package spacegray-theme
       :config
       (progn (load-theme 'spacegray)))
    #+END_SRC
** Modeline
   #+BEGIN_SRC emacs-lisp
   (req-package smart-mode-line
     :config
     (progn
       (sml/setup)
       (setq sml/mode-width 'full)
       (setq sml/show-file-name nil)
       (setq sml/shorten-directory nil)
       (sml/apply-theme 'respectful)
     ))
   #+END_SRC
** Cleanup
   Who wants all that toolbars and scrollbars noise?

   #+BEGIN_SRC emacs-lisp
     (req-package scroll-bar
                  :config
                  (scroll-bar-mode -1))

     (req-package tool-bar
                  :config
                  (tool-bar-mode -1))

     (req-package menu-bar
                  :config
                  (menu-bar-mode -1))
   #+END_SRC

   I also use [[http://www.emacswiki.org/emacs/DiminishedModes][diminish]] to clean up the modeline.

   #+BEGIN_SRC emacs-lisp
     (req-package diminish)

     (req-package server
                  :diminish (server-buffer-clients . ""))
   #+END_SRC

* IDE
  A few conveniences that I like to have in all my =prog-mode= buffers.

** Whitespace & Indentation
   Fuck those tabs right off.
   #+BEGIN_SRC emacs-lisp
   (setq-default indent-tabs-mode nil)
   (setq-default tab-width 2)
   (setq indent-line-function 'insert-tab)
   (global-set-key (kbd "C-c i c") 'indent-to-column)
   (req-package whitespace-cleanup-mode
     :diminish ""
     :config
     (progn
       (add-hook 'prog-mode-hook '(lambda ()
         (make-local-variable 'before-save-hook)
         (add-hook 'before-save-hook 'whitespace-cleanup)
       ))))
   #+END_SRC

** Magit
   The only git wrapper that matters.

   #+BEGIN_SRC emacs-lisp
     (req-package magit
       :diminish magit-auto-revert-mode
       :require magit-gitflow)
   #+END_SRC

** Line Numbers
   #+BEGIN_SRC emacs-lisp
     (req-package linum
       :config
       (add-hook 'prog-mode-hook
                 '(lambda () (linum-mode 1))))
   #+END_SRC

*** Relative Line Numbers
    I was a little spoiled by this feature in Vim, and not having it
    just doesn't sit well with me.

    #+BEGIN_SRC emacs-lisp
      (req-package linum-relative
        :init (setq linum-relative-current-symbol ""))
    #+END_SRC

** Delimiters
   I like my delimiters matched and visually distinct. I used [[https://bitbucket.org/kovisoft/paredit][paredit]] for a
   long time, but I'm currently experimenting with [[https://github.com/Fuco1/smartparens][smartparens]]. As for the
   visual element, I quite like [[https://github.com/jlr/rainbow-delimiters][rainbow-delimiters]].

   #+BEGIN_SRC emacs-lisp
     (req-package smartparens-config
       :ensure smartparens
       :diminish (smartparens-mode . "()")
       :init (smartparens-global-mode t))

     (req-package rainbow-delimiters
       :config
       (add-hook 'prog-mode-hook 'rainbow-delimiters-mode))
   #+END_SRC

** Colors
   I've had to work with colors in a fair bit of code, so having them displayed
   in buffer is convenient.

   #+BEGIN_SRC emacs-lisp
     (req-package rainbow-mode
       :diminish (rainbow-mode . "")
       :config (add-hook 'prog-mode-hook 'rainbow-mode))
   #+END_SRC

   There's also an interesting mode for uniquely coloring identifiers in code
   so that they are easy to scan for. It's still a bit iffy, but it's fun to
   try.

   #+BEGIN_SRC emacs-lisp
     (req-package color-identifiers-mode
       :diminish (color-identifiers-mode . "")
       :init
       (setq color-identifiers:num-colors 50)
       :config
       (progn
         (add-hook 'emacs-lisp-mode-hook 'color-identifiers-mode)
         (add-hook 'ruby-mode-hook 'color-identifiers-mode)))
   #+END_SRC

** Tags
   #+BEGIN_SRC emacs-lisp
     (req-package ggtags)
   #+END_SRC

** Fill Column Indicator
  #+BEGIN_SRC emacs-lisp
  (req-package fill-column-indicator
    :diminish (fci-mode . "")
    :config
    (progn
      (define-globalized-minor-mode global-fci-mode fci-mode (lambda () (fci-mode 1)))
      (global-fci-mode 1)))
  #+END_SRC
** Comment TODO Highlighting
   #+BEGIN_SRC emacs-lisp
   (req-package fic-mode
     :diminish ""
     :config
     (progn
       (add-hook 'prog-mode-hook 'fic-mode)))
   #+END_SRC
** =wgrep=
   Because being able to edit an rgrep result and have things save
   properly in each file is awesome!
   #+BEGIN_SRC emacs-lisp
     (req-package wgrep)
   #+END_SRC
* Languages
** Haskell
   #+BEGIN_SRC emacs-lisp
     (req-package haskell-mode
       :commands haskell-mode
       :init
       (add-to-list 'auto-mode-alist '("\\.l?hs$" . haskell-mode))
       :config
       (progn
         (req-package inf-haskell)
         (req-package hs-lint)
         (defun my-haskell-hook ()
           (setq mode-name " λ ")
           (turn-on-haskell-doc)
           (diminish 'haskell-doc-mode "")
           (capitalized-words-mode)
           (diminish 'capitalized-words-mode "")
           (turn-on-eldoc-mode)
           (turn-on-haskell-indentation)
           (diminish 'eldoc-mode "")
           (turn-on-haskell-decl-scan))
         (setq haskell-font-lock-symbols 'unicode)
         (setq haskell-literate-default 'tex)
         (setq haskell-stylish-on-save t)
         (setq haskell-tags-on-save t)
         (add-hook 'haskell-mode-hook 'my-haskell-hook)))
     (req-package ghc
       :init (add-hook 'haskell-mode-hook (lambda () (ghc-init)))) 
   #+END_SRC
** Scala
   #+BEGIN_SRC emacs-lisp
   (req-package scala-mode2
     :config
     (progn
       (add-hook 'scala-mode-hook '(lambda ()
         (capitalized-words-mode)
       ))))
   #+END_SRC
** Coffeescript
   #+BEGIN_SRC emacs-lisp
   (req-package coffee-mode)
   #+END_SRC
** Emacs Lisp
   #+BEGIN_SRC emacs-lisp
     (req-package lisp-mode
       :init
       (add-hook 'emacs-lisp-mode-hook
                 (lambda ()
                   (setq mode-name " ξ "))))
   #+END_SRC

** LaTeX
   All you need is AUCTeX, end of story.

   #+BEGIN_SRC emacs-lisp
     (req-package tex-site
       :require auto-complete-config
       :ensure auctex
       :config
       (progn
         (setq TeX-view-program-selection '((output-pdf "PDF Viewer")))
         (setq TeX-view-program-list
           '(("PDF Viewer" "/Applications/Skim.app/Contents/SharedSupport/displayline -b -g %n %o %b")))))

   #+END_SRC

** Idris
   #+BEGIN_SRC emacs-lisp
     (req-package idris-mode)
   #+END_SRC

** Javascript
   #+BEGIN_SRC emacs-lisp
     (req-package tern
       :require tern-auto-complete
       :init
       (progn
         (add-hook 'js-mode-hook
                   (lambda ()
                     (tern-mode t))))
       :config
       (progn
         (tern-ac-setup)))

     (req-package tern-auto-complete)
   #+END_SRC

** Purescript
   #+BEGIN_SRC emacs-lisp
     (add-to-list 'load-path "~/.emacs.d/vendor/purescript-mode/")
     (require 'purescript-mode-autoloads)
     (add-to-list 'Info-default-directory-list "~/.emacs.d/vendor/purescript-mode/")
     (add-to-list 'load-path "~/.emacs.d/vendor/purscheck/")
     (require 'purscheck)
   #+END_SRC
** ElmJS
   #+BEGIN_SRC emacs-lisp
     (req-package elm-mode)
   #+END_SRC
** Markdown 
   #+BEGIN_SRC emacs-lisp
     (req-package markdown-mode
       :config 
       (progn
         (add-to-list 'auto-mode-alist '("\\.markdown\\'" . markdown-mode))
         (add-to-list 'auto-mode-alist '("\\.md\\'" . markdown-mode))))
   #+END_SRC
* Annoyances
  Fixing a couple of gripes I have with Emacs.

** Exec path
   #+BEGIN_SRC emacs-lisp
     (req-package exec-path-from-shell
       :init
       (when (memq window-system '(mac ns))
         (exec-path-from-shell-initialize)))
   #+END_SRC

** Backups and Autosave Files
   These things end up everywhere, so let's stick them all in a temporary
   directory. Also remove the annoying lockfiles.

   #+BEGIN_SRC emacs-lisp
     (req-package files
       :init
       (progn
         (setq backup-directory-alist
               `((".*" . ,temporary-file-directory)))
         (setq auto-save-file-name-transforms
               `((".*" ,temporary-file-directory t)))))
         (setq create-lockfiles nil)
   #+END_SRC

** Questions
   Keep it short.

   #+BEGIN_SRC emacs-lisp
     (defalias 'yes-or-no-p 'y-or-n-p)
   #+END_SRC

** Startup Screen
  #+BEGIN_SRC emacs-lisp
  (setq inhibit-startup-message t)
  #+END_SRC

* Fulfill Requirements
  At long last we need only call the following function to send =req-package= on
  its merry way.

  #+BEGIN_SRC emacs-lisp
    (req-package-finish)
  #+END_SRC
